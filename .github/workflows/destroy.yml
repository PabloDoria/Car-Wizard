name: Destroy Infrastructure

on:
  workflow_dispatch:  # Permite ejecución manual desde GitHub

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  TF_VAR_rds_password: ${{ secrets.RDS_PASSWORD }}
  VPC_NAME: "car-wizard-vpc"

jobs:
  terraform-destroy:
    name: Destroy Infrastructure
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      - name: Force Delete ECS Resources
        run: |
          echo "Eliminando servicios ECS..."
          CLUSTER_NAME="car-wizard-cluster"
          SERVICE_NAME="car-wizard-service"
          
          # Verificar si el cluster existe
          CLUSTER_EXISTS=$(aws ecs describe-clusters --clusters $CLUSTER_NAME --query 'clusters[0].status' --output text 2>/dev/null || echo "INACTIVE")
          
          if [ "$CLUSTER_EXISTS" != "INACTIVE" ]; then
            echo "Cluster encontrado, procediendo con la eliminación de servicios..."
            
            # Verificar si el servicio existe
            SERVICE_EXISTS=$(aws ecs list-services --cluster $CLUSTER_NAME --query 'serviceArns[0]' --output text 2>/dev/null || echo "")
            
            if [ ! -z "$SERVICE_EXISTS" ] && [ "$SERVICE_EXISTS" != "None" ]; then
              echo "Servicio encontrado, procediendo con la eliminación..."
              
              # Escalar el servicio a 0
              aws ecs update-service --cluster $CLUSTER_NAME --service $SERVICE_NAME --desired-count 0 || true
              
              # Esperar a que los tasks se detengan (máximo 5 minutos)
              timeout=300
              while [ $timeout -gt 0 ]; do
                TASKS=$(aws ecs list-tasks --cluster $CLUSTER_NAME --service-name $SERVICE_NAME --query 'taskArns' --output text)
                if [ -z "$TASKS" ] || [ "$TASKS" == "None" ]; then
                  break
                fi
                echo "Esperando que los tasks se detengan... ($timeout segundos restantes)"
                sleep 10
                timeout=$((timeout-10))
              done
              
              # Forzar eliminación de tareas restantes
              TASKS=$(aws ecs list-tasks --cluster $CLUSTER_NAME --query 'taskArns[]' --output text) || true
              if [ ! -z "$TASKS" ] && [ "$TASKS" != "None" ]; then
                echo "Forzando eliminación de tareas..."
                for TASK in $TASKS; do
                  aws ecs stop-task --cluster $CLUSTER_NAME --task $TASK --reason "Destroy infrastructure" || true
                done
              fi
              
              # Eliminar el servicio
              echo "Eliminando servicio ECS..."
              aws ecs delete-service --cluster $CLUSTER_NAME --service $SERVICE_NAME --force || true
            else
              echo "No se encontró el servicio ECS, continuando..."
            fi
            
            # Eliminar el cluster
            echo "Eliminando cluster ECS..."
            aws ecs delete-cluster --cluster $CLUSTER_NAME || true
          else
            echo "No se encontró el cluster ECS, continuando..."
          fi

      - name: Force Delete Lambda Resources
        run: |
          echo "Eliminando recursos de Lambda..."
          # Eliminar permisos y triggers primero
          aws events remove-targets --rule trigger-car-data-update --ids TriggerLambda || true
          aws events delete-rule --name trigger-car-data-update || true
          aws lambda delete-function --function-name LoadDataLambda || true

      - name: Force Delete Load Balancer
        run: |
          echo "Eliminando Load Balancer..."
          # Obtener ARN del ALB
          ALB_ARN=$(aws elbv2 describe-load-balancers --names car-wizard-alb --query 'LoadBalancers[0].LoadBalancerArn' --output text) || true
          if [ ! -z "$ALB_ARN" ] && [ "$ALB_ARN" != "None" ]; then
            # Eliminar listeners
            LISTENERS=$(aws elbv2 describe-listeners --load-balancer-arn $ALB_ARN --query 'Listeners[*].ListenerArn' --output text) || true
            for listener in $LISTENERS; do
              aws elbv2 delete-listener --listener-arn $listener || true
            done
            # Eliminar el ALB
            aws elbv2 delete-load-balancer --load-balancer-arn $ALB_ARN || true
          fi
          
          # Eliminar target groups
          TG_ARN=$(aws elbv2 describe-target-groups --names car-wizard-tg --query 'TargetGroups[0].TargetGroupArn' --output text) || true
          if [ ! -z "$TG_ARN" ] && [ "$TG_ARN" != "None" ]; then
            aws elbv2 delete-target-group --target-group-arn $TG_ARN || true
          fi

      - name: Clean up ECR Repository
        if: always()
        run: |
          echo "Limpiando repositorio ECR..."
          REPO_NAME="car-wizard"
          aws ecr list-images --repository-name $REPO_NAME --query 'imageIds[*]' --output json | \
          jq -r '.[] | [.imageDigest] | @tsv' | \
          while read digest; do
            aws ecr batch-delete-image --repository-name $REPO_NAME --image-ids imageDigest=$digest || true
          done
          aws ecr delete-repository --repository-name $REPO_NAME --force || true

      - name: Force Delete RDS Resources
        run: |
          echo "Eliminando recursos de RDS..."
          
          # Eliminar instancia RDS
          DB_IDENTIFIER="car-wizard-db"
          echo "Eliminando instancia RDS $DB_IDENTIFIER..."
          aws rds delete-db-instance --db-instance-identifier $DB_IDENTIFIER --skip-final-snapshot --delete-automated-backups || true
          
          # Esperar a que la instancia se elimine (máximo 20 minutos)
          echo "Esperando a que la instancia RDS se elimine..."
          timeout=1200
          while [ $timeout -gt 0 ]; do
            DB_STATUS=$(aws rds describe-db-instances --db-instance-identifier $DB_IDENTIFIER --query 'DBInstances[0].DBInstanceStatus' --output text 2>/dev/null || echo "deleted")
            if [ "$DB_STATUS" == "deleted" ] || [ "$DB_STATUS" == "None" ]; then
              echo "Instancia RDS eliminada"
              break
            fi
            echo "Estado de RDS: $DB_STATUS ($timeout segundos restantes)"
            sleep 30
            timeout=$((timeout-30))
          done
          
          # Eliminar subnet groups
          echo "Eliminando DB subnet groups..."
          aws rds delete-db-subnet-group --db-subnet-group-name car-wizard-rds-subnet-group || true
          
          # Eliminar parameter groups
          echo "Eliminando DB parameter groups..."
          aws rds delete-db-parameter-group --db-parameter-group-name $(aws rds describe-db-parameter-groups --query 'DBParameterGroups[?starts_with(DBParameterGroupName, `car-wizard-params-`)].DBParameterGroupName' --output text) || true

      - name: Force Delete Network Resources
        run: |
          echo "Eliminando recursos de red..."
          
          # Obtener VPC ID
          VPC_ID=$(aws ec2 describe-vpcs --filters "Name=tag:Name,Values=${VPC_NAME}" --query 'Vpcs[0].VpcId' --output text)
          
          if [ ! -z "$VPC_ID" ] && [ "$VPC_ID" != "None" ]; then
            echo "Eliminando recursos asociados a VPC $VPC_ID..."

            # 1. Eliminar ECS Tasks y esperar
            echo "Verificando y eliminando tareas ECS..."
            CLUSTER_NAME="car-wizard-cluster"
            aws ecs update-service --cluster $CLUSTER_NAME --service car-wizard-service --desired-count 0 || true
            sleep 30

            # 2. Eliminar ALB y esperar
            echo "Eliminando Load Balancer..."
            ALB_ARN=$(aws elbv2 describe-load-balancers --names car-wizard-alb --query 'LoadBalancers[0].LoadBalancerArn' --output text) || true
            if [ ! -z "$ALB_ARN" ] && [ "$ALB_ARN" != "None" ]; then
              aws elbv2 delete-load-balancer --load-balancer-arn $ALB_ARN || true
              echo "Esperando que el ALB se elimine..."
              while aws elbv2 describe-load-balancers --names car-wizard-alb 2>/dev/null; do
                echo "ALB aún existe, esperando..."
                sleep 30
              done
            fi

            # 3. Eliminar Target Groups
            echo "Eliminando Target Groups..."
            TG_ARN=$(aws elbv2 describe-target-groups --names car-wizard-tg --query 'TargetGroups[0].TargetGroupArn' --output text) || true
            if [ ! -z "$TG_ARN" ] && [ "$TG_ARN" != "None" ]; then
              aws elbv2 delete-target-group --target-group-arn $TG_ARN || true
            fi

            # 4. Esperar y eliminar ENIs
            echo "Esperando 60 segundos antes de proceder con ENIs..."
            sleep 60

            # 5. Eliminar ENIs con reintentos
            for attempt in {1..5}; do
              echo "Intento $attempt de eliminar Network Interfaces..."
              ENIs=$(aws ec2 describe-network-interfaces --filters "Name=vpc-id,Values=$VPC_ID" --query 'NetworkInterfaces[*].NetworkInterfaceId' --output text) || true
              if [ ! -z "$ENIs" ] && [ "$ENIs" != "None" ]; then
                for eni in $ENIs; do
                  echo "Procesando ENI $eni..."
                  # Obtener información del ENI
                  ATTACHMENT=$(aws ec2 describe-network-interfaces --network-interface-ids $eni --query 'NetworkInterfaces[0].Attachment.AttachmentId' --output text) || true
                  
                  if [ ! -z "$ATTACHMENT" ] && [ "$ATTACHMENT" != "None" ]; then
                    echo "Desvinculando ENI $eni..."
                    aws ec2 detach-network-interface --attachment-id $ATTACHMENT --force || true
                    sleep 10
                  fi
                  
                  echo "Eliminando ENI $eni..."
                  aws ec2 delete-network-interface --network-interface-id $eni --force || true
                done
                echo "Esperando 30 segundos antes del siguiente intento..."
                sleep 30
              else
                echo "No se encontraron ENIs para eliminar"
                break
              fi
            done

            # 6. Eliminar Security Groups
            echo "Eliminando Security Groups..."
            
            # Primero eliminar todas las reglas de ingreso y egreso
            echo "Eliminando reglas de los Security Groups..."
            SEC_GROUPS=$(aws ec2 describe-security-groups --filters "Name=vpc-id,Values=$VPC_ID" --query 'SecurityGroups[*].[GroupId,IpPermissions,IpPermissionsEgress]' --output json) || true
            
            if [ ! -z "$SEC_GROUPS" ] && [ "$SEC_GROUPS" != "null" ]; then
              echo "$SEC_GROUPS" | jq -c '.[]' | while read -r group; do
                GROUP_ID=$(echo "$group" | jq -r '.[0]')
                echo "Procesando Security Group $GROUP_ID..."
                
                # Eliminar reglas de ingreso (IpPermissions)
                if [ "$(echo "$group" | jq '.[1]')" != "[]" ] && [ "$(echo "$group" | jq '.[1]')" != "null" ]; then
                  echo "Eliminando reglas de ingreso..."
                  aws ec2 revoke-security-group-ingress \
                    --group-id "$GROUP_ID" \
                    --ip-permissions "$(echo "$group" | jq '.[1]')" || true
                fi
                
                # Eliminar reglas de egreso (IpPermissionsEgress)
                if [ "$(echo "$group" | jq '.[2]')" != "[]" ] && [ "$(echo "$group" | jq '.[2]')" != "null" ]; then
                  echo "Eliminando reglas de egreso..."
                  aws ec2 revoke-security-group-egress \
                    --group-id "$GROUP_ID" \
                    --ip-permissions "$(echo "$group" | jq '.[2]')" || true
                fi
              done
              
              echo "Esperando 30 segundos después de eliminar las reglas..."
              sleep 30
            fi

            # Luego intentar eliminar los security groups no predeterminados
            for attempt in {1..3}; do
              echo "Intento $attempt de eliminar Security Groups..."
              SEC_GROUPS=$(aws ec2 describe-security-groups --filters "Name=vpc-id,Values=$VPC_ID" "Name=group-name,Values=!default" --query 'SecurityGroups[*].GroupId' --output text) || true
              if [ ! -z "$SEC_GROUPS" ] && [ "$SEC_GROUPS" != "None" ]; then
                for sg in $SEC_GROUPS; do
                  echo "Eliminando Security Group $sg..."
                  aws ec2 delete-security-group --group-id $sg || true
                done
                echo "Esperando 20 segundos antes del siguiente intento..."
                sleep 20
              else
                break
              fi
            done

            # Finalmente, intentar eliminar el grupo de seguridad default
            DEFAULT_SG=$(aws ec2 describe-security-groups --filters "Name=vpc-id,Values=$VPC_ID" "Name=group-name,Values=default" --query 'SecurityGroups[*].GroupId' --output text) || true
            if [ ! -z "$DEFAULT_SG" ] && [ "$DEFAULT_SG" != "None" ]; then
              echo "Eliminando reglas del Security Group default..."
              # Obtener y eliminar todas las reglas del grupo default
              DEFAULT_SG_RULES=$(aws ec2 describe-security-groups --group-ids $DEFAULT_SG --query 'SecurityGroups[0].[IpPermissions,IpPermissionsEgress]' --output json) || true
              
              # Eliminar reglas de ingreso
              if [ "$(echo "$DEFAULT_SG_RULES" | jq '.[0]')" != "[]" ] && [ "$(echo "$DEFAULT_SG_RULES" | jq '.[0]')" != "null" ]; then
                aws ec2 revoke-security-group-ingress \
                  --group-id "$DEFAULT_SG" \
                  --ip-permissions "$(echo "$DEFAULT_SG_RULES" | jq '.[0]')" || true
              fi
              
              # Eliminar reglas de egreso
              if [ "$(echo "$DEFAULT_SG_RULES" | jq '.[1]')" != "[]" ] && [ "$(echo "$DEFAULT_SG_RULES" | jq '.[1]')" != "null" ]; then
                aws ec2 revoke-security-group-egress \
                  --group-id "$DEFAULT_SG" \
                  --ip-permissions "$(echo "$DEFAULT_SG_RULES" | jq '.[1]')" || true
              fi
            fi

            # 7. Eliminar Route Tables
            echo "Eliminando Route Tables..."
            ROUTE_TABLES=$(aws ec2 describe-route-tables --filters "Name=vpc-id,Values=$VPC_ID" --query 'RouteTables[?Associations[0].Main!=`true`].RouteTableId' --output text) || true
            for rt in $ROUTE_TABLES; do
              ASSOC_IDS=$(aws ec2 describe-route-tables --route-table-ids $rt --query 'RouteTables[*].Associations[*].RouteTableAssociationId' --output text) || true
              for assoc in $ASSOC_IDS; do
                aws ec2 disassociate-route-table --association-id $assoc || true
              done
              aws ec2 delete-route-table --route-table-id $rt || true
            done

            # 8. Eliminar Internet Gateway
            echo "Eliminando Internet Gateway..."
            IGW_ID=$(aws ec2 describe-internet-gateways --filters "Name=attachment.vpc-id,Values=$VPC_ID" --query 'InternetGateways[*].InternetGatewayId' --output text) || true
            if [ ! -z "$IGW_ID" ] && [ "$IGW_ID" != "None" ]; then
              aws ec2 detach-internet-gateway --internet-gateway-id $IGW_ID --vpc-id $VPC_ID || true
              sleep 15
              aws ec2 delete-internet-gateway --internet-gateway-id $IGW_ID || true
            fi

            # 9. Eliminar Subnets
            echo "Eliminando Subnets..."
            for attempt in {1..3}; do
              SUBNETS=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$VPC_ID" --query 'Subnets[*].SubnetId' --output text) || true
              if [ ! -z "$SUBNETS" ] && [ "$SUBNETS" != "None" ]; then
                for subnet in $SUBNETS; do
                  aws ec2 delete-subnet --subnet-id $subnet || true
                done
                sleep 30
              else
                break
              fi
            done

            # 10. Esperar y verificar recursos restantes
            echo "Esperando 60 segundos antes de eliminar la VPC..."
            sleep 60

            # 11. Verificar y mostrar recursos restantes
            echo "Verificando recursos restantes en la VPC..."
            aws ec2 describe-network-interfaces --filters "Name=vpc-id,Values=$VPC_ID" || true
            aws ec2 describe-security-groups --filters "Name=vpc-id,Values=$VPC_ID" || true
            aws ec2 describe-subnets --filters "Name=vpc-id,Values=$VPC_ID" || true

            # 12. Intentar eliminar la VPC
            echo "Intentando eliminar la VPC..."
            aws ec2 delete-vpc --vpc-id $VPC_ID || true

            # 13. Verificar si la VPC se eliminó
            if aws ec2 describe-vpcs --vpc-ids $VPC_ID 2>/dev/null; then
              echo "⚠️ La VPC no se pudo eliminar. Recursos restantes:"
              aws ec2 describe-network-interfaces --filters "Name=vpc-id,Values=$VPC_ID" || true
              aws ec2 describe-security-groups --filters "Name=vpc-id,Values=$VPC_ID" || true
              aws ec2 describe-subnets --filters "Name=vpc-id,Values=$VPC_ID" || true
              exit 1
            else
              echo "✅ VPC eliminada exitosamente"
            fi
          fi

      - name: Force Delete Service Roles
        run: |
          echo "Eliminando roles de servicio..."
          
          # Lista de roles de servicio (excluyendo GHActionsRole)
          SERVICE_ROLES=(
            "LambdaExecutionRole"
            "ecsTaskExecutionRole"
          )
          
          for ROLE_NAME in "${SERVICE_ROLES[@]}"; do
            echo "Procesando rol: $ROLE_NAME"
            
            # Obtener y eliminar políticas inline
            INLINE_POLICIES=$(aws iam list-role-policies --role-name $ROLE_NAME --query 'PolicyNames[*]' --output text) || true
            for POLICY in $INLINE_POLICIES; do
              echo "Eliminando política inline $POLICY del rol $ROLE_NAME"
              aws iam delete-role-policy --role-name $ROLE_NAME --policy-name $POLICY || true
            done
            
            # Desasociar políticas administradas
            ATTACHED_POLICIES=$(aws iam list-attached-role-policies --role-name $ROLE_NAME --query 'AttachedPolicies[*].PolicyArn' --output text) || true
            for POLICY_ARN in $ATTACHED_POLICIES; do
              echo "Desvinculando política $POLICY_ARN del rol $ROLE_NAME"
              aws iam detach-role-policy --role-name $ROLE_NAME --policy-arn $POLICY_ARN || true
            done
            
            # Eliminar el rol
            echo "Eliminando rol $ROLE_NAME"
            aws iam delete-role --role-name $ROLE_NAME || true
          done

      - name: Force Delete CloudWatch Logs
        run: |
          echo "Eliminando grupos de logs de CloudWatch..."
          
          # Eliminar grupo de logs de Lambda
          aws logs delete-log-group --log-group-name "/aws/lambda/LoadDataLambda" || true
          
          # Eliminar grupos de logs de ECS
          LOG_GROUPS=$(aws logs describe-log-groups --log-group-name-prefix "/ecs/car-wizard-" --query 'logGroups[*].logGroupName' --output text) || true
          for log_group in $LOG_GROUPS; do
            echo "Eliminando grupo de logs $log_group..."
            aws logs delete-log-group --log-group-name "$log_group" || true
          done

      - name: Terraform Destroy
        working-directory: terraform
        run: terraform destroy -auto-approve
        env:
          TF_VAR_rds_password: ${{ secrets.RDS_PASSWORD }}